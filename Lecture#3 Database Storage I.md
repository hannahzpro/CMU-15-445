# CMU15-445/645 Lecture#3 Database Storage I

### 面向磁盘的DBMS(DISK-ORIENTED ARCHITECTURE)

数据库全部在磁盘上，数据库文件中的数据被组织成页面，第一页是目录页面。 为了对数据进行操作，DBMS需要将数据带入内存。它通过具有一个缓冲池来实现此目的，该缓冲池管理着磁盘和内存之间的来回移动。 DBMS还具有将执行查询的执行引擎。 执行引擎将向缓冲池询问特定的页面，并且缓冲池将负责将该页面带入内存并为执行引擎提供指向内存中页面的指针。 当执行引擎在该内存上运行时，缓冲池管理器将确保页面在那里。

![截屏2021-01-25上午9.09.29](/Users/hannahzhang/Desktop/截屏2021-01-25上午9.09.29.png)



==任何时候，我们尝试读取的东西都不在内存中==，**DBMS管理了数据从非易失性存储到易失性存储的移动 ** 

`易失性存储`：

+ 断电以后失去缓存

+ 访问速度快，跳转到任意位置所需时间几乎相同，*字节寻址*

`非易失性存储`：

+ 不需要稳定的能量去保存其中的内容
+ *块寻址*，希望最大化地按顺序读取数据量



### FILE STORAGE



DBMS将数据库存储为磁盘上的一个或多个文件。

→操作系统对这些文件的内容一无所知。

#### STORAGE MANAGER（储存管理器）

*The storage manager is responsible for maintaining a database's files.*

储存管理器是数据库系统中的一个组件，负责维护磁盘上的数据库文件



把文件组织为一个pages的集合

→ 储存管理器将跟踪我们在这些pages上面执行的所有读取和写入操作

→ Tracks the available space

#### DATABASE PAGES

**一个page就是一个固定大小的数据块**

+ 可以储存几乎任何信息
+ 大多数情况不会page混合使用不同类型的数据

每个page都会被赋予一个唯一的内部标识符(page ID)

* Indirection层允许我们将一个pageID映射到某个集合中一个文件中的某个位置，（即记录一个相对位置，方便文件整体移动后，只要知道整体文件的初始位置，依然可以通过该相对位置即PageID找到某个文件某个位置的信息）



一些Page concepts：

+ Hardware Page (usually 4KB)  **从实际存储设备本身获得的page**
+ OS Page (usually 4KB)  **操作系统page，从存储设备中取出数据，放入内存中**
+ Database Page(512B-16KB)  **数据库page**



#### PAGE STORAGE ARCHITECTURE

不同的DBMS以不同的方式管理磁盘上文件中的页面。

→**堆文件组织**

→顺序/排序文件组织

→哈希文件组织



#### DATABASE HEAP

堆文件是页面的**无序**集合，其中元组以随机顺序存储。

→创建/获取/写入/删除页面

→还必须支持遍历所有页面 

+ 需要一些额外空间储存哪些pages存在&哪些是空余的空间
+ 最底层称为pages，可以用不同的数据结构表示

#### HEAP FILE ： LINKED LIST

*（并没有人用这种方法）*

在文件的开头维护一个头页面，该页面存储两个指针：

+ 空闲页面列表的HEAD。

+ 数据页列表的HEAD。

每个页面都跟踪其自身的可用插槽数

#### PAGE DIRECTORY

*（一般方法）*

DBMS维护特殊页面，这些页面跟踪数据库文件中数据页面的位置。

该目录还记录每页的可用插槽数。

DBMS必须确保目录页面与数据页面同步

### PAGE LAYOUT

#### Page Header

每个页面都包含有关页面内容的元数据的标头。

→页面大小

→校验和(checksum)

→DBMS版本

→交易可见性

→压缩信息

对于任何页面存储体系结构，我们现在都需要了解如何组织存储在页面内部的数据。

→我们仍然假设我们仅存储元组。

#### Page的布局

Two approaches: 
+ Tuple-oriented 

  **Tuple Storage**： 跟踪页面中元组的数量，然后在末尾附加一个新的元组。

  删除操作存在问题 it sucks

  **Slotted Pages**：

  最常见的布局方案称为分页页面。

  插槽数组将“插槽”映射到元组的起始位置偏移量。

  标头跟踪：

  + 已使用插槽的数量

  +  最后使用的插槽起始位置的偏移量

  ![截屏2021-01-25下午9.05.30](/Users/hannahzhang/Desktop/截屏2021-01-25下午9.05.30.png)

  

+ Log-structured

### TUPLE LAYOUT

#### TUPLE HEADER

每个元组均以包含有关元数据的标头为前缀。

→可见性信息（并发控制）

→NULL值的位图

我们不需要存储有关架构的元数据，可以将这种更高级的元数据信息保存在则个page里面



#### TUPLE DATA

属性通常以创建表时指定它们的顺序存储。

这样做是出于软件工程方面的原因。

